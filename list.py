# -*- coding: utf-8 -*-

# Form implementation generated from reading ui file 'list.ui'
#
# Created by: PyQt5 UI code generator 5.15.2
#
# WARNING: Any manual changes made to this file will be lost when pyuic5 is
# run again.  Do not edit this file unless you know what you are doing.


from PyQt5 import QtCore, QtGui, QtWidgets
from PyQt5.QtCore import QTimer,QThread,pyqtSignal,QEventLoop
from PyQt5.QtWidgets import QApplication, QMenu, QAction, QSystemTrayIcon
import sys
import threading
from subprocess import Popen, PIPE
import json
from F1 import currentdir
from multiprocessing import Process #better multithread function
from multiprocessing import Pool

mode = ""
try:
    optiondict = json.load(open(currentdir + r"\option.json", "r"))
    mode = optiondict.get("mode", "")
except Exception as e:
    print("ha?")
    pass
def sleep(sec):
    loop = QEventLoop()
    QTimer.singleShot(sec*1000, loop.quit)
    loop.exec_()


class Job(threading.Thread):

    def __init__(self, target=None, *args, **kwargs):
        super(Job, self).__init__(*args, **kwargs)
        self.__flag = threading.Event()  # 用于暂停线程的标识
        self.__flag.set()  # 设置为True
        self.__running = threading.Event()  # 用于停止线程的标识
        self.__running.set()  # 将running设置为True
        self._target = target
        if kwargs is None:
            kwargs = {}
        self._args = args
        self._kwargs = kwargs

    def run(self):
        while self.__running.isSet():
            self.__flag.wait()  # 为True时立即返回, 为False时阻塞直到内部的标识位为True后返回
            try:
                if self._target:
                    self._target(*self._args, **self._kwargs)
            finally:
                # Avoid a refcycle if the thread is running a function with
                # an argument that has a member that points to the thread.
                del self._target, self._args, self._kwargs
            self.stop()

    def pause(self):
        self.__flag.clear()  # 设置为False, 让线程阻塞

    def resume(self):
        self.__flag.set()  # 设置为True, 让线程停止阻塞

    def stop(self):
        self.__flag.set()  # 将线程从暂停状态恢复, 如何已经暂停的话
        self.__running.clear()  # 设置为False


class Job2(threading.Thread):

    def __init__(self, target=None, arg=["", ""], *args, **kwargs):
        super(Job2, self).__init__(*args, **kwargs)
        self.__end = False
        self.__flag = threading.Event()  # 用于暂停线程的标识
        self.__flag.set()  # 设置为True
        self.__running = threading.Event()  # 用于停止线程的标识
        self.__running.set()  # 将running设置为True
        self._target = target
        if kwargs is None:
            kwargs = {}
        self._args = args
        self.e = arg
        self._kwargs = kwargs

    def run(self):
        while self.__running.isSet():
            self.__flag.wait()  # 为True时立即返回, 为False时阻塞直到内部的标识位为True后返回
            try:
                if self._target:
                    self._target(self.e[0], self.e[1])
            finally:
                # Avoid a refcycle if the thread is running a function with
                # an argument that has a member that points to the thread.
                del self._target, self._args, self._kwargs
                self.__end = True
            self.stop()

    def pause(self):
        self.__flag.clear()  # 设置为False, 让线程阻塞

    def resume(self):
        self.__flag.set()  # 设置为True, 让线程停止阻塞

    def stop(self):
        self.__flag.set()  # 将线程从暂停状态恢复, 如何已经暂停的话
        self.__end = True
        self.__running.clear()  # 设置为False

    def get_end(self):
        return self.__end


class Ui_List(object):
    def setupUi(self, List):
        _translate = QtCore.QCoreApplication.translate
        List.setWindowTitle(_translate("List", "Queue"))
        List.setObjectName("List")
        List.resize(311, 254)
        List.setMinimumSize(QtCore.QSize(311, 254))
        List.setMaximumSize(QtCore.QSize(311, 254))
        self.icon = QtGui.QIcon()
        self.icon.addPixmap(QtGui.QPixmap(":/q/src/电视粉.png"), QtGui.QIcon.Normal, QtGui.QIcon.Off)
        List.setWindowIcon(self.icon)
        self.threads = []

        self.buttonBox = QtWidgets.QDialogButtonBox(List)
        self.buttonBox.setGeometry(QtCore.QRect(220, 20, 81, 241))
        self.buttonBox.setOrientation(QtCore.Qt.Vertical)
        self.buttonBox.setStandardButtons(QtWidgets.QDialogButtonBox.Cancel | QtWidgets.QDialogButtonBox.Ok)
        self.buttonBox.setObjectName("buttonBox")
        self.label = QtWidgets.QLabel(List)
        self.label.setGeometry(QtCore.QRect(228, 200, 71, 30))
        self.label.setObjectName("label")
        self.scrollArea = QtWidgets.QScrollArea(List)
        self.scrollArea.setGeometry(QtCore.QRect(0, 0, 211, 251))
        self.scrollArea.setWidgetResizable(True)
        self.scrollArea.setObjectName("scrollArea")
        self.scrollAreaWidgetContents = QtWidgets.QWidget()
        self.scrollAreaWidgetContents.setGeometry(QtCore.QRect(0, 0, 209, 249))
        self.scrollAreaWidgetContents.setObjectName("scrollAreaWidgetContents")
        self.listWidget = QtWidgets.QListWidget(self.scrollAreaWidgetContents)
        self.listWidget.setGeometry(QtCore.QRect(0, 0, 211, 251))
        self.listWidget.setGridSize(QtCore.QSize(0, 25))
        self.listWidget.setObjectName("listWidget")
        self.createNewItem("enter url here")
        self.createNewItem("e.g. ss6038@1-12")

        self.scrollArea.setWidget(self.scrollAreaWidgetContents)
        self.add = QtWidgets.QToolButton(List)
        self.add.setGeometry(QtCore.QRect(230, 120, 21, 21))
        self.add.setCheckable(False)
        self.add.setObjectName("add")
        self.dele = QtWidgets.QToolButton(List)
        self.dele.setGeometry(QtCore.QRect(270, 120, 21, 21))
        self.dele.setObjectName("dele")
        self.start = QtWidgets.QPushButton(List)
        self.start.setGeometry(QtCore.QRect(225, 160, 75, 23))
        self.start.setObjectName("start")
        self.add.setText(_translate("List", "+"))
        self.dele.setText(_translate("List", "-"))
        self.start.setText("开始")
        self.status = 0

        self.label.setText(_translate("List", "共 2 个任务"))
        __sortingEnabled = self.listWidget.isSortingEnabled()
        self.listWidget.setSortingEnabled(False)
        self.listWidget.setSortingEnabled(__sortingEnabled)
        # 双击可编辑
        self.edited_item = self.listWidget.currentItem()
        self.close_flag = True
        self.listWidget.doubleClicked.connect(self.item_double_clicked)
        self.listWidget.currentItemChanged.connect(self.close_edit)
        self.add.clicked.connect(self.edit_new_item)
        self.dele.clicked.connect(self.del_item_from_list)
        ###MAKEDOWN:debug point
        self.start.clicked.connect(lambda :(Job2(self.start_clicked()).start()))
        self.buttonBox.accepted.connect(self.oKclicked)
        self.buttonBox.rejected.connect(self.cancelclicked)
        QtCore.QMetaObject.connectSlotsByName(List)

    def del_item_from_list(self):
        item = self.listWidget.currentItem()
        self.listWidget.takeItem(self.listWidget.row(item))
        self.label.setText("共 " + str(self.listWidget.count()) + " 个任务")

    def createNewItem(self, text):
        item = QtWidgets.QListWidgetItem()
        font = QtGui.QFont()
        font.setFamily("幼圆")
        font.setPointSize(14)
        item.setFont(font)
        item.setText(text)
        brush = QtGui.QBrush(QtGui.QColor(255, 69, 240))
        item.setForeground(brush)
        self.listWidget.addItem(item)

    def oKclicked(self):
        self.minisys()
        self.hide()
        pass

    def cancelclicked(self):
        self.close()

    def quit(self):
        sys.exit(0)

    def keyPressEvent(self, e: QtGui.QKeyEvent) -> None:
        """回车事件，关闭edit"""
        self.listWidget.keyPressEvent(e)
        if e.key() == QtCore.Qt.Key_Return:
            if self.close_flag:
                self.close_edit()
            self.close_flag = True

    def edit_new_item(self) -> None:
        """edit一个新的item"""
        self.close_flag = False
        self.close_edit()
        count = self.listWidget.count()
        self.createNewItem('')
        item = self.listWidget.item(count)
        self.edited_item = item
        self.listWidget.openPersistentEditor(item)
        self.listWidget.editItem(item)
        self.label.setText("共 " + str(self.listWidget.count()) + " 个任务")

    def item_double_clicked(self, modelindex: QtCore.QModelIndex) -> None:
        """双击事件"""
        self.close_edit()
        item = self.listWidget.item(modelindex.row())
        self.edited_item = item
        self.listWidget.openPersistentEditor(item)
        self.listWidget.editItem(item)

    def close_edit(self, *_) -> None:
        """关闭edit"""
        if self.edited_item and self.listWidget.isPersistentEditorOpen(self.edited_item):
            self.listWidget.closePersistentEditor(self.edited_item)

    def minisys(self):
        self.tray = QSystemTrayIcon()  # 创建系统托盘对象
        self.tray.setIcon(self.icon)  # 设置系统托盘图标
        self.tray.setToolTip("blbldl-Queue")
        # self.tray.activated.connect(self.TuoPanEvent)  # 设置托盘点击事件处理函数
        self.tray_menu = QMenu(QApplication.desktop())  # 创建菜单
        self.RestoreAction = QAction(u'还原 ', self, triggered=self.show)  # 添加一级菜单动作选项(还原主窗口)
        self.QuitAction = QAction(u'退出 ', self, triggered=self.close)  # 添加一级菜单动作选项(退出程序)
        self.tray_menu.addAction(self.RestoreAction)  # 为菜单添加动作
        self.tray_menu.addAction(self.QuitAction)
        self.tray.setContextMenu(self.tray_menu)  # 设置系统托盘菜单
        self.tray.showMessage('blbldl-Queue', 'blbldl is running', icon=1)

        def act(reason):
            # 鼠标点击icon传递的信号会带有一个整形的值，1是表示单击右键，2是双击，3是单击左键，4是用鼠标中键点击
            if reason == 2:
                self.show()
            # print("系统托盘的图标被点击了")

        self.tray.activated.connect(act)
        self.tray.show()

    def startDL(self, item):
        global mode
        choice = item.text().split("@")
        link = choice[0]
        cc = ""
        if (len(choice) == 2):
            cc = choice[1]
        else:
            cc = "1-0"
        while True:

            for i in self.threads:
                if i.get_end():
                    self.threads.remove(i)
            if 0 <= len(self.threads) < 4:
                a = Job2(Popen(currentdir + r"\blbldl " + link + " " + mode + " " + self.choice, stdin=PIPE,
                               stdout=open("Logs.txt", "w+", encoding="utf-8"),
                               stderr=PIPE))
                a.start()
                self.threads.append(a)
                break
            else:
                sleep(10)
                continue
        self.listWidget.takeItem(0)
        return True

    def closeEvent(self, e):
        if threading.active_count() >= 2:
            e.ignore()
            self.hide()
            self.minisys()
        else:
            e.accept()

    def queue_continue(self):
        while (True):
            for p, i in enumerate(self.threads):
                if i.is_alive():
                    continue
                else:
                    self.listWidget.takeItem(self.listWidget.row(i.getItem()))
                    self.label.setText("共 " + str(self.listWidget.count()) + " 个任务")
                    try:
                        item = self.listWidget.item(3)
                        choice = item.text().split("@")
                        if (len(choice) == 2):
                            self.create_New_TDL(p, choice[0], choice[1], item)
                        if (len(choice) == 1):
                            self.create_New_TDL(p, choice[0], "1-0", item)
                        continue
                    except Exception:
                        continue
            if threading.active_count() == 2:
                self.status = 3
                self.start_clicked()
                return
            else:
                sleep(10.0)

    def start_clicked(self):
        if self.status == 0:
            if self.listWidget.count() == 0:
                self.status = 3
            else:
                self.listWidget.item(0)
                self.a = Job2(self.startDL())
                self.status = 1
                self.start.setText("暂停")
                self.label.setText("已开始下载\n" + self.label.text())
                self.update
                self.a.start()
                return
        elif self.status == 2:
            for i in self.threads:
                if i.is_alive():
                    i.resume()
            try:
                if self.b.is_alive():
                    self.b.resume()
            except Exception:
                pass
            self.status = 1
            self.start.setText("暂停")
            self.update
            return
        elif self.status == 3:
            self.start.setText("开始")
            self.label.setText("下载结束\n" + self.label.text())
            self.status = 0
            self.update
            return
        else:
            for i in self.threads:
                if i.is_alive():
                    i.pause()
            try:
                if self.b.is_alive():
                    self.b.pause()
            except Exception:
                pass
            self.status = 2
            self.start.setText("开始")
            self.update
            return


from PyQt5.QtWidgets import QMainWindow


class ListWindow(QMainWindow, Ui_List):
    def __init__(self, parent=None):
        super(ListWindow, self).__init__(parent)
        self.setupUi(self)


if __name__ == "__main__":
    app = QApplication(sys.argv)
    # QApplication.setQuitOnLastWindowClosed(False)
    listw = ListWindow()
    listw.show()
    Process(target=listw.start_clicked()).start()
    sys.exit(app.exec_())
